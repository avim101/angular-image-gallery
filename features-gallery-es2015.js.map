{"version":3,"sources":["./node_modules/ng-lazyload-image/fesm2015/ng-lazyload-image.js","./node_modules/ngx-infinite-scroll/modules/ngx-infinite-scroll.js","./src/app/components/image-card/image-card.component.html","./src/app/features/gallery/gallery.component.html","./src/app/components/image-card/image-card.component.scss","./src/app/components/image-card/image-card.component.ts","./src/app/components/image-card/index.ts","./src/app/features/gallery/gallery-routing.module.ts","./src/app/features/gallery/gallery.component.scss","./src/app/features/gallery/gallery.component.ts","./src/app/features/gallery/gallery.module.ts","./src/app/features/gallery/index.ts","./src/app/features/gallery/services/gallery.sandbox.service.ts","./src/app/features/gallery/services/gallery.service.ts"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAwD;AACL;AACiF;AAC/D;AACkD;;AAEvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,aAAa;AAC9C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,UAAU;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc,UAAU;AACxB,oBAAoB,wCAAwC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,wBAAwB,qCAAqC;AAC7D;AACA;AACA;AACA,yBAAyB,gCAAgC;AACzD;AACA;AACA,gBAAgB,uCAAuC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC,4CAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kBAAkB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,+CAAU;AACrB,sDAAsD,6DAAM;AAC5D;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,WAAW,+CAAE;AACb;AACA,sBAAsB,YAAY;AAClC;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,mCAAmC,6DAAM;AACzC;AACA;AACA;AACA;AACA,SAAS,IAAI,2DAAI,KAAK,+DAAQ,uCAAuC,0DAAG;AACxE;AACA;AACA;AACA,SAAS,IAAI,0DAAG,cAAc,iEAAU;AACxC;AACA,mBAAmB,+CAAE;AACrB,SAAS,GAAG,0DAAG;AACf;AACA;;AAEA;AACA;AACA,0BAA0B,0DAAY,GAAG;AACzC;AACA;AACA,oCAAoC,kDAAa;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,YAAY,wEAAgB;AAC5B;AACA;AACA;AACA;AACA,sBAAsB,0DAAG,8CAA8C,gEAAS;AAChF;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAU;AACV,IAAI,2DAAK;AACT,IAAI,wDAAU;AACd;AACA,wDAAU;AACV,IAAI,2DAAK;AACT,IAAI,wDAAU;AACd;AACA,wDAAU;AACV,IAAI,2DAAK;AACT,IAAI,wDAAU;AACd;AACA,wDAAU;AACV,IAAI,2DAAK;AACT,IAAI,wDAAU;AACd;AACA,wDAAU;AACV,IAAI,2DAAK;AACT,IAAI,wDAAU,gBAAgB,+CAAU;AACxC;AACA,wDAAU;AACV,IAAI,2DAAK;AACT,IAAI,wDAAU;AACd;AACA,wDAAU;AACV,IAAI,2DAAK;AACT,IAAI,wDAAU;AACd;AACA,wDAAU;AACV,IAAI,2DAAK;AACT,IAAI,wDAAU;AACd;AACA,wDAAU;AACV,IAAI,4DAAM;AACV,IAAI,wDAAU,gBAAgB,0DAAY;AAC1C;AACA,yBAAyB,wDAAU;AACnC,IAAI,+DAAS;AACb;AACA,KAAK;AACL,IAAI,qDAAO,IAAI,4DAAM,CAAC,yDAAW,IAAI,qDAAO,IAAI,8DAAQ,KAAK,qDAAO,IAAI,4DAAM;AAC9E,IAAI,wDAAU,uBAAuB,wDAAU,EAAE,oDAAM;AACvD;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wCAAwC;AACjE;AACA;AACA;AACA,8CAA8C,wDAAU;AACxD,IAAI,8DAAQ;AACZ;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,2BAA2B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,iEAAU,kBAAkB,4DAAK,IAAI,gEAAS;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kDAAK;AACpB;AACA;AACA;AACA;AACA;AACA,uBAAuB,+CAAU;AACjC;AACA;AACA,yBAAyB;AACzB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,sBAAsB,mCAAmC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,gEAAS;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA,CAAC;;AAEgG;AACjG;;;;;;;;;;;;;ACrbA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAqG;AAChE;AACmC;;AAExE;AACA;AACA,cAAc,uEAAuE;AACrF;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA,eAAe,EAAE;AACjB;AACA,eAAe,EAAE;AACjB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA,kDAAkD,0BAA0B;AAC5E;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,uEAAuE;AACrF;AACA,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,uEAAuE;AACrF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,uEAAuE;AACrF;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA,yBAAyB,sBAAsB;AAC/C,wCAAwC,iDAAiD;AACzF;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA,2BAA2B,aAAa,YAAY;AACpD;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA,WAAW,4BAA4B;AACvC,WAAW,mCAAmC;AAC9C;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA,eAAe,EAAE;AACjB;AACA;AACA,YAAY;AACZ;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA,eAAe,EAAE;AACjB;AACA,eAAe,EAAE;AACjB;AACA,YAAY;AACZ;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA,kCAAkC,4BAA4B;AAC9D,WAAW,mCAAmC;AAC9C;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA,eAAe,EAAE;AACjB;AACA,eAAe,EAAE;AACjB;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,uEAAuE;AACrF;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA,eAAe,EAAE;AACjB;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;;AAEA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;;AAEA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;;AAEA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;;AAEA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;;AAEA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;;AAEA;AACA;AACA,cAAc,uEAAuE;AACrF;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,uEAAuE;AACrF;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA,WAAW,mDAAmD;AAC9D,eAAe,EAAE;AACjB;AACA;AACA;AACA,KAAK;AACL,eAAe,EAAE;AACjB;AACA;AACA,KAAK;AACL,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA,2CAA2C,+DAAQ,OAAO,+CAAE,uCAAuC,0DAAG,sGAAsG,0DAAG,GAAG,QAAQ,qEAAqE,6DAAM,GAAG,2BAA2B,gBAAgB,EAAE,kHAAkH,0DAAG,GAAG,qBAAqB,gBAAgB,EAAE;AACpf;AACA,KAAK,GAAG,0DAAG;AACX;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA,eAAe,EAAE;AACjB,cAAc,sDAAS;AACvB;AACA;AACA;AACA;AACA,uBAAuB,iEAAU;AACjC;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA,WAAW,qBAAqB,kCAAkC,EAAE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,uEAAuE;AACrF;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA,4BAA4B,0DAAY;AACxC,8BAA8B,0DAAY;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA,iBAAiB,0EAA0E;AAC3F,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA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","file":"features-gallery-es2015.js","sourcesContent":["import { __decorate, __metadata, __param } from 'tslib';\nimport { isPlatformServer } from '@angular/common';\nimport { EventEmitter, Input, Output, Directive, Inject, PLATFORM_ID, Optional, ElementRef, NgZone, NgModule } from '@angular/core';\nimport { Subject, Observable, of, ReplaySubject, empty } from 'rxjs';\nimport { filter, take, mergeMap, tap, map, catchError, switchMap, sampleTime, share, startWith } from 'rxjs/operators';\n\nconst cssClassNames = {\n    loaded: 'ng-lazyloaded',\n    loading: 'ng-lazyloading',\n    failed: 'ng-failed-lazyloaded'\n};\nfunction removeCssClassName(element, cssClassName) {\n    element.className = element.className.replace(cssClassName, '');\n}\nfunction addCssClassName(element, cssClassName) {\n    if (!element.className.includes(cssClassName)) {\n        element.className += ` ${cssClassName}`;\n    }\n}\nfunction hasCssClassName(element, cssClassName) {\n    return element.className && element.className.includes(cssClassName);\n}\n\nfunction getNavigator() {\n    return typeof window !== 'undefined' ? window.navigator : undefined;\n}\nfunction isChildOfPicture(element) {\n    return Boolean(element.parentElement && element.parentElement.nodeName.toLowerCase() === 'picture');\n}\nfunction isImageElement(element) {\n    return element.nodeName.toLowerCase() === 'img';\n}\nfunction setImage(element, imagePath, useSrcset) {\n    if (isImageElement(element)) {\n        if (useSrcset && 'srcset' in element) {\n            element.srcset = imagePath;\n        }\n        else {\n            element.src = imagePath;\n        }\n    }\n    else {\n        element.style.backgroundImage = `url('${imagePath}')`;\n    }\n    return element;\n}\nfunction setSources(attrName) {\n    return (image) => {\n        const sources = image.parentElement.getElementsByTagName('source');\n        for (let i = 0; i < sources.length; i++) {\n            const attrValue = sources[i].getAttribute(attrName);\n            if (attrValue) {\n                // Check if `srcset` is supported by the current browser\n                if ('srcset' in sources[i]) {\n                    sources[i].srcset = attrValue;\n                }\n                else {\n                    sources[i].src = attrValue;\n                }\n            }\n        }\n    };\n}\nconst setSourcesToDefault = setSources('defaultImage');\nconst setSourcesToLazy = setSources('lazyLoad');\nconst setSourcesToError = setSources('errorImage');\nfunction setImageAndSources(setSourcesFn) {\n    return (element, imagePath, useSrcset) => {\n        if (isImageElement(element) && isChildOfPicture(element)) {\n            setSourcesFn(element);\n        }\n        if (imagePath) {\n            setImage(element, imagePath, useSrcset);\n        }\n    };\n}\nconst setImageAndSourcesToDefault = setImageAndSources(setSourcesToDefault);\nconst setImageAndSourcesToLazy = setImageAndSources(setSourcesToLazy);\nconst setImageAndSourcesToError = setImageAndSources(setSourcesToError);\n\nconst end = ({ element }) => addCssClassName(element, cssClassNames.loaded);\nconst loadImage = ({ element, useSrcset, imagePath, decode }) => {\n    let img;\n    if (isImageElement(element) && isChildOfPicture(element)) {\n        const parentClone = element.parentNode.cloneNode(true);\n        img = parentClone.getElementsByTagName('img')[0];\n        setSourcesToLazy(img);\n        setImage(img, imagePath, useSrcset);\n    }\n    else {\n        img = new Image();\n        if (isImageElement(element) && element.sizes) {\n            img.sizes = element.sizes;\n        }\n        if (useSrcset && 'srcset' in img) {\n            img.srcset = imagePath;\n        }\n        else {\n            img.src = imagePath;\n        }\n    }\n    if (decode && img.decode) {\n        return img.decode().then(() => imagePath);\n    }\n    return new Promise((resolve, reject) => {\n        img.onload = () => resolve(imagePath);\n        img.onerror = () => reject(null);\n    });\n};\nconst setErrorImage = ({ element, errorImagePath, useSrcset }) => {\n    setImageAndSourcesToError(element, errorImagePath, useSrcset);\n    addCssClassName(element, cssClassNames.failed);\n};\nconst setLoadedImage = ({ element, imagePath, useSrcset }) => {\n    setImageAndSourcesToLazy(element, imagePath, useSrcset);\n};\nconst setup = ({ element, defaultImagePath, useSrcset }) => {\n    setImageAndSourcesToDefault(element, defaultImagePath, useSrcset);\n    if (hasCssClassName(element, cssClassNames.loaded)) {\n        removeCssClassName(element, cssClassNames.loaded);\n    }\n};\nconst isBot = navigator => {\n    if (navigator && navigator.userAgent) {\n        return /googlebot|bingbot|yandex|baiduspider|facebookexternalhit|twitterbot|rogerbot|linkedinbot|embedly|quora\\ link\\ preview|showyoubot|outbrain|pinterest\\/0\\.|pinterestbot|slackbot|vkShare|W3C_Validator|whatsapp|duckduckbot/i.test(navigator.userAgent);\n    }\n    return false;\n};\nconst sharedPreset = {\n    finally: end,\n    loadImage,\n    setErrorImage,\n    setLoadedImage,\n    setup,\n    isBot\n};\n\nconst observers = new WeakMap();\nconst intersectionSubject = new Subject();\nfunction loadingCallback(entrys) {\n    entrys.forEach(entry => intersectionSubject.next(entry));\n}\nconst uniqKey = {};\nconst getIntersectionObserver = (attributes) => {\n    const scrollContainerKey = attributes.scrollContainer || uniqKey;\n    const options = {\n        root: attributes.scrollContainer || null\n    };\n    if (attributes.offset) {\n        options.rootMargin = `${attributes.offset}px`;\n    }\n    let observer = observers.get(scrollContainerKey);\n    if (!observer) {\n        observer = new IntersectionObserver(loadingCallback, options);\n        observers.set(scrollContainerKey, observer);\n    }\n    observer.observe(attributes.element);\n    return Observable.create((obs) => {\n        const subscription = intersectionSubject.pipe(filter(entry => entry.target === attributes.element)).subscribe(obs);\n        return () => {\n            subscription.unsubscribe();\n            observer.unobserve(attributes.element);\n        };\n    });\n};\n\nconst isVisible = ({ event }) => {\n    return event.isIntersecting;\n};\nconst getObservable = (attributes, _getInterObserver = getIntersectionObserver) => {\n    if (attributes.customObservable) {\n        return attributes.customObservable;\n    }\n    return _getInterObserver(attributes);\n};\nconst intersectionObserverPreset = Object.assign({}, sharedPreset, {\n    isVisible,\n    getObservable\n});\n\nconst isVisible$1 = () => {\n    return true;\n};\nconst getObservable$1 = () => {\n    return of('load');\n};\nconst loadImage$1 = ({ imagePath }) => {\n    return [imagePath];\n};\nconst ssrPreset = Object.assign({}, sharedPreset, {\n    isVisible: isVisible$1,\n    getObservable: getObservable$1,\n    loadImage: loadImage$1\n});\n\nfunction createHooks(platformId, options) {\n    const defaultPreset = intersectionObserverPreset;\n    const isBot = options && options.isBot ? options.isBot : defaultPreset.isBot;\n    if (isBot(getNavigator(), platformId)) {\n        return Object.assign(ssrPreset, { isBot });\n    }\n    else if (!options) {\n        return defaultPreset;\n    }\n    const hooks = {};\n    if (options.preset) {\n        Object.assign(hooks, options.preset);\n    }\n    else {\n        Object.assign(hooks, defaultPreset);\n    }\n    Object.keys(options)\n        .filter(key => key !== 'preset')\n        .forEach(key => {\n        hooks[key] = options[key];\n    });\n    return hooks;\n}\n\nfunction lazyLoadImage(hookSet, attributes) {\n    return (evntObservable) => {\n        return evntObservable.pipe(filter(event => hookSet.isVisible({\n            element: attributes.element,\n            event: event,\n            offset: attributes.offset,\n            scrollContainer: attributes.scrollContainer\n        })), take(1), mergeMap(() => hookSet.loadImage(attributes)), tap(imagePath => hookSet.setLoadedImage({\n            element: attributes.element,\n            imagePath,\n            useSrcset: attributes.useSrcset\n        })), map(() => true), catchError(() => {\n            hookSet.setErrorImage(attributes);\n            return of(false);\n        }), tap(() => hookSet.finally(attributes)));\n    };\n}\n\nlet LazyLoadImageDirective = class LazyLoadImageDirective {\n    constructor(el, ngZone, platformId, options) {\n        this.onLoad = new EventEmitter(); // Callback when an image is loaded\n        this.elementRef = el;\n        this.ngZone = ngZone;\n        this.propertyChanges$ = new ReplaySubject();\n        this.platformId = platformId;\n        this.hooks = createHooks(platformId, options);\n    }\n    ngOnChanges() {\n        this.propertyChanges$.next({\n            element: this.elementRef.nativeElement,\n            imagePath: this.lazyImage,\n            defaultImagePath: this.defaultImage,\n            errorImagePath: this.errorImage,\n            useSrcset: this.useSrcset,\n            offset: this.offset ? this.offset | 0 : 0,\n            scrollContainer: this.scrollTarget,\n            customObservable: this.customObservable,\n            decode: this.decode\n        });\n    }\n    ngAfterContentInit() {\n        // Don't do anything if SSR and the user isn't a bot\n        if (isPlatformServer(this.platformId) && !this.hooks.isBot(getNavigator(), this.platformId)) {\n            return null;\n        }\n        this.ngZone.runOutsideAngular(() => {\n            this.scrollSubscription = this.propertyChanges$\n                .pipe(tap(attributes => this.hooks.setup(attributes)), switchMap(attributes => this.hooks.getObservable(attributes).pipe(lazyLoadImage(this.hooks, attributes))))\n                .subscribe(success => this.onLoad.emit(success));\n        });\n    }\n    ngOnDestroy() {\n        if (this.scrollSubscription) {\n            this.scrollSubscription.unsubscribe();\n        }\n    }\n};\n__decorate([\n    Input('lazyLoad'),\n    __metadata(\"design:type\", String)\n], LazyLoadImageDirective.prototype, \"lazyImage\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], LazyLoadImageDirective.prototype, \"defaultImage\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], LazyLoadImageDirective.prototype, \"errorImage\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object)\n], LazyLoadImageDirective.prototype, \"scrollTarget\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Observable)\n], LazyLoadImageDirective.prototype, \"customObservable\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Number)\n], LazyLoadImageDirective.prototype, \"offset\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Boolean)\n], LazyLoadImageDirective.prototype, \"useSrcset\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Boolean)\n], LazyLoadImageDirective.prototype, \"decode\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", EventEmitter)\n], LazyLoadImageDirective.prototype, \"onLoad\", void 0);\nLazyLoadImageDirective = __decorate([\n    Directive({\n        selector: '[lazyLoad]'\n    }),\n    __param(2, Inject(PLATFORM_ID)), __param(3, Optional()), __param(3, Inject('options')),\n    __metadata(\"design:paramtypes\", [ElementRef, NgZone, Object, Object])\n], LazyLoadImageDirective);\n\nvar LazyLoadImageModule_1;\nlet LazyLoadImageModule = LazyLoadImageModule_1 = class LazyLoadImageModule {\n    static forRoot(options) {\n        return {\n            ngModule: LazyLoadImageModule_1,\n            providers: [{ provide: 'options', useValue: options }]\n        };\n    }\n};\nLazyLoadImageModule = LazyLoadImageModule_1 = __decorate([\n    NgModule({\n        declarations: [LazyLoadImageDirective],\n        exports: [LazyLoadImageDirective]\n    })\n], LazyLoadImageModule);\n\nclass Rect {\n    constructor(left, top, right, bottom) {\n        this.left = left;\n        this.top = top;\n        this.right = right;\n        this.bottom = bottom;\n    }\n    static fromElement(element) {\n        const { left, top, right, bottom } = element.getBoundingClientRect();\n        if (left === 0 && top === 0 && right === 0 && bottom === 0) {\n            return Rect.empty;\n        }\n        else {\n            return new Rect(left, top, right, bottom);\n        }\n    }\n    static fromWindow(_window) {\n        return new Rect(0, 0, _window.innerWidth, _window.innerHeight);\n    }\n    inflate(inflateBy) {\n        this.left -= inflateBy;\n        this.top -= inflateBy;\n        this.right += inflateBy;\n        this.bottom += inflateBy;\n    }\n    intersectsWith(rect) {\n        return rect.left < this.right && this.left < rect.right && rect.top < this.bottom && this.top < rect.bottom;\n    }\n    getIntersectionWith(rect) {\n        const left = Math.max(this.left, rect.left);\n        const top = Math.max(this.top, rect.top);\n        const right = Math.min(this.right, rect.right);\n        const bottom = Math.min(this.bottom, rect.bottom);\n        if (right >= left && bottom >= top) {\n            return new Rect(left, top, right, bottom);\n        }\n        else {\n            return Rect.empty;\n        }\n    }\n}\nRect.empty = new Rect(0, 0, 0, 0);\n\nconst scrollListeners = new WeakMap();\nfunction sampleObservable(obs, scheduler) {\n    return obs.pipe(sampleTime(100, scheduler), share(), startWith(''));\n}\n// Only create one scroll listener per target and share the observable.\n// Typical, there will only be one observable per application\nconst getScrollListener = (scrollTarget) => {\n    if (!scrollTarget || typeof scrollTarget.addEventListener !== 'function') {\n        console.warn('`addEventListener` on ' + scrollTarget + ' (scrollTarget) is not a function. Skipping this target');\n        return empty();\n    }\n    const scrollListener = scrollListeners.get(scrollTarget);\n    if (scrollListener) {\n        return scrollListener;\n    }\n    const srollEvent = Observable.create((observer) => {\n        const eventName = 'scroll';\n        const handler = (event) => observer.next(event);\n        const options = { passive: true, capture: false };\n        scrollTarget.addEventListener(eventName, handler, options);\n        return () => scrollTarget.removeEventListener(eventName, handler, options);\n    });\n    const listener = sampleObservable(srollEvent);\n    scrollListeners.set(scrollTarget, listener);\n    return listener;\n};\n\nconst isVisible$2 = ({ element, offset, scrollContainer }, getWindow = () => window) => {\n    const elementBounds = Rect.fromElement(element);\n    if (elementBounds === Rect.empty) {\n        return false;\n    }\n    const windowBounds = Rect.fromWindow(getWindow());\n    elementBounds.inflate(offset);\n    if (scrollContainer) {\n        const scrollContainerBounds = Rect.fromElement(scrollContainer);\n        const intersection = scrollContainerBounds.getIntersectionWith(windowBounds);\n        return elementBounds.intersectsWith(intersection);\n    }\n    else {\n        return elementBounds.intersectsWith(windowBounds);\n    }\n};\nconst getObservable$2 = (attributes) => {\n    if (attributes.customObservable) {\n        return attributes.customObservable.pipe(startWith(''));\n    }\n    if (attributes.scrollContainer) {\n        return getScrollListener(attributes.scrollContainer);\n    }\n    return getScrollListener(window);\n};\nconst scrollPreset = Object.assign({}, sharedPreset, {\n    isVisible: isVisible$2,\n    getObservable: getObservable$2\n});\n\nexport { LazyLoadImageDirective, LazyLoadImageModule, intersectionObserverPreset, scrollPreset };\n//# sourceMappingURL=ng-lazyload-image.js.map\n","import { Directive, ElementRef, EventEmitter, Input, NgModule, NgZone, Output } from '@angular/core';\nimport { fromEvent, of } from 'rxjs';\nimport { filter, map, mergeMap, sampleTime, tap } from 'rxjs/operators';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} selector\n * @param {?} scrollWindow\n * @param {?} defaultElement\n * @param {?} fromRoot\n * @return {?}\n */\nfunction resolveContainerElement(selector, scrollWindow, defaultElement, fromRoot) {\n    /** @type {?} */\n    const hasWindow = window && !!window.document && window.document.documentElement;\n    /** @type {?} */\n    let container = hasWindow && scrollWindow ? window : defaultElement;\n    if (selector) {\n        /** @type {?} */\n        const containerIsString = selector && hasWindow && typeof selector === 'string';\n        container = containerIsString\n            ? findElement(selector, defaultElement.nativeElement, fromRoot)\n            : selector;\n        if (!container) {\n            throw new Error('ngx-infinite-scroll {resolveContainerElement()}: selector for');\n        }\n    }\n    return container;\n}\n/**\n * @param {?} selector\n * @param {?} customRoot\n * @param {?} fromRoot\n * @return {?}\n */\nfunction findElement(selector, customRoot, fromRoot) {\n    /** @type {?} */\n    const rootEl = fromRoot ? window.document : customRoot;\n    return rootEl.querySelector(selector);\n}\n/**\n * @param {?} prop\n * @return {?}\n */\nfunction inputPropChanged(prop) {\n    return prop && !prop.firstChange;\n}\n/**\n * @return {?}\n */\nfunction hasWindowDefined() {\n    return typeof window !== 'undefined';\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst VerticalProps = {\n    clientHeight: \"clientHeight\",\n    offsetHeight: \"offsetHeight\",\n    scrollHeight: \"scrollHeight\",\n    pageYOffset: \"pageYOffset\",\n    offsetTop: \"offsetTop\",\n    scrollTop: \"scrollTop\",\n    top: \"top\"\n};\n/** @type {?} */\nconst HorizontalProps = {\n    clientHeight: \"clientWidth\",\n    offsetHeight: \"offsetWidth\",\n    scrollHeight: \"scrollWidth\",\n    pageYOffset: \"pageXOffset\",\n    offsetTop: \"offsetLeft\",\n    scrollTop: \"scrollLeft\",\n    top: \"left\"\n};\nclass AxisResolver {\n    /**\n     * @param {?=} vertical\n     */\n    constructor(vertical = true) {\n        this.vertical = vertical;\n        this.propsMap = vertical ? VerticalProps : HorizontalProps;\n    }\n    /**\n     * @return {?}\n     */\n    clientHeightKey() {\n        return this.propsMap.clientHeight;\n    }\n    /**\n     * @return {?}\n     */\n    offsetHeightKey() {\n        return this.propsMap.offsetHeight;\n    }\n    /**\n     * @return {?}\n     */\n    scrollHeightKey() {\n        return this.propsMap.scrollHeight;\n    }\n    /**\n     * @return {?}\n     */\n    pageYOffsetKey() {\n        return this.propsMap.pageYOffset;\n    }\n    /**\n     * @return {?}\n     */\n    offsetTopKey() {\n        return this.propsMap.offsetTop;\n    }\n    /**\n     * @return {?}\n     */\n    scrollTopKey() {\n        return this.propsMap.scrollTop;\n    }\n    /**\n     * @return {?}\n     */\n    topKey() {\n        return this.propsMap.top;\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @record\n */\n\n/**\n * @record\n */\n\n/**\n * @record\n */\n\n/**\n * @record\n */\n\n/**\n * @param {?} alwaysCallback\n * @param {?} shouldFireScrollEvent\n * @param {?} isTriggeredCurrentTotal\n * @return {?}\n */\nfunction shouldTriggerEvents(alwaysCallback, shouldFireScrollEvent, isTriggeredCurrentTotal) {\n    if (alwaysCallback && shouldFireScrollEvent) {\n        return true;\n    }\n    if (!isTriggeredCurrentTotal && shouldFireScrollEvent) {\n        return true;\n    }\n    return false;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} __0\n * @return {?}\n */\nfunction createResolver({ windowElement, axis }) {\n    return createResolverWithContainer({ axis, isWindow: isElementWindow(windowElement) }, windowElement);\n}\n/**\n * @param {?} resolver\n * @param {?} windowElement\n * @return {?}\n */\nfunction createResolverWithContainer(resolver, windowElement) {\n    /** @type {?} */\n    const container = resolver.isWindow || (windowElement && !windowElement.nativeElement)\n        ? windowElement\n        : windowElement.nativeElement;\n    return Object.assign({}, resolver, { container });\n}\n/**\n * @param {?} windowElement\n * @return {?}\n */\nfunction isElementWindow(windowElement) {\n    /** @type {?} */\n    const isWindow = ['Window', 'global'].some((obj) => Object.prototype.toString.call(windowElement).includes(obj));\n    return isWindow;\n}\n/**\n * @param {?} isContainerWindow\n * @param {?} windowElement\n * @return {?}\n */\nfunction getDocumentElement(isContainerWindow, windowElement) {\n    return isContainerWindow ? windowElement.document.documentElement : null;\n}\n/**\n * @param {?} element\n * @param {?} resolver\n * @return {?}\n */\nfunction calculatePoints(element, resolver) {\n    /** @type {?} */\n    const height = extractHeightForElement(resolver);\n    return resolver.isWindow\n        ? calculatePointsForWindow(height, element, resolver)\n        : calculatePointsForElement(height, element, resolver);\n}\n/**\n * @param {?} height\n * @param {?} element\n * @param {?} resolver\n * @return {?}\n */\nfunction calculatePointsForWindow(height, element, resolver) {\n    const { axis, container, isWindow } = resolver;\n    const { offsetHeightKey, clientHeightKey } = extractHeightPropKeys(axis);\n    // scrolled until now / current y point\n    /** @type {?} */\n    const scrolled = height +\n        getElementPageYOffset(getDocumentElement(isWindow, container), axis, isWindow);\n    // total height / most bottom y point\n    /** @type {?} */\n    const nativeElementHeight = getElementHeight(element.nativeElement, isWindow, offsetHeightKey, clientHeightKey);\n    /** @type {?} */\n    const totalToScroll = getElementOffsetTop(element.nativeElement, axis, isWindow) +\n        nativeElementHeight;\n    return { height, scrolled, totalToScroll, isWindow };\n}\n/**\n * @param {?} height\n * @param {?} element\n * @param {?} resolver\n * @return {?}\n */\nfunction calculatePointsForElement(height, element, resolver) {\n    const { axis, container } = resolver;\n    // perhaps use container.offsetTop instead of 'scrollTop'\n    /** @type {?} */\n    const scrolled = container[axis.scrollTopKey()];\n    /** @type {?} */\n    const totalToScroll = container[axis.scrollHeightKey()];\n    return { height, scrolled, totalToScroll, isWindow: false };\n}\n/**\n * @param {?} axis\n * @return {?}\n */\nfunction extractHeightPropKeys(axis) {\n    return {\n        offsetHeightKey: axis.offsetHeightKey(),\n        clientHeightKey: axis.clientHeightKey()\n    };\n}\n/**\n * @param {?} __0\n * @return {?}\n */\nfunction extractHeightForElement({ container, isWindow, axis }) {\n    const { offsetHeightKey, clientHeightKey } = extractHeightPropKeys(axis);\n    return getElementHeight(container, isWindow, offsetHeightKey, clientHeightKey);\n}\n/**\n * @param {?} elem\n * @param {?} isWindow\n * @param {?} offsetHeightKey\n * @param {?} clientHeightKey\n * @return {?}\n */\nfunction getElementHeight(elem, isWindow, offsetHeightKey, clientHeightKey) {\n    if (isNaN(elem[offsetHeightKey])) {\n        /** @type {?} */\n        const docElem = getDocumentElement(isWindow, elem);\n        return docElem ? docElem[clientHeightKey] : 0;\n    }\n    else {\n        return elem[offsetHeightKey];\n    }\n}\n/**\n * @param {?} elem\n * @param {?} axis\n * @param {?} isWindow\n * @return {?}\n */\nfunction getElementOffsetTop(elem, axis, isWindow) {\n    /** @type {?} */\n    const topKey = axis.topKey();\n    // elem = elem.nativeElement;\n    if (!elem.getBoundingClientRect) {\n        // || elem.css('none')) {\n        return;\n    }\n    return (elem.getBoundingClientRect()[topKey] +\n        getElementPageYOffset(elem, axis, isWindow));\n}\n/**\n * @param {?} elem\n * @param {?} axis\n * @param {?} isWindow\n * @return {?}\n */\nfunction getElementPageYOffset(elem, axis, isWindow) {\n    /** @type {?} */\n    const pageYOffset = axis.pageYOffsetKey();\n    /** @type {?} */\n    const scrollTop = axis.scrollTopKey();\n    /** @type {?} */\n    const offsetTop = axis.offsetTopKey();\n    if (isNaN(window[pageYOffset])) {\n        return getDocumentElement(isWindow, elem)[scrollTop];\n    }\n    else if (elem.ownerDocument) {\n        return elem.ownerDocument.defaultView[pageYOffset];\n    }\n    else {\n        return elem[offsetTop];\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} container\n * @param {?} distance\n * @param {?} scrollingDown\n * @return {?}\n */\nfunction shouldFireScrollEvent(container, distance, scrollingDown) {\n    /** @type {?} */\n    let remaining;\n    /** @type {?} */\n    let containerBreakpoint;\n    if (container.totalToScroll <= 0) {\n        return false;\n    }\n    /** @type {?} */\n    const scrolledUntilNow = container.isWindow ? container.scrolled : container.height + container.scrolled;\n    if (scrollingDown) {\n        remaining =\n            (container.totalToScroll - scrolledUntilNow) / container.totalToScroll;\n        containerBreakpoint = distance.down / 10;\n    }\n    else {\n        /** @type {?} */\n        const totalHiddenContentHeight = container.scrolled + (container.totalToScroll - scrolledUntilNow);\n        remaining = container.scrolled / totalHiddenContentHeight;\n        containerBreakpoint = distance.up / 10;\n    }\n    /** @type {?} */\n    const shouldFireEvent = remaining <= containerBreakpoint;\n    return shouldFireEvent;\n}\n/**\n * @param {?} lastScrollPosition\n * @param {?} container\n * @return {?}\n */\nfunction isScrollingDownwards(lastScrollPosition, container) {\n    return lastScrollPosition < container.scrolled;\n}\n/**\n * @param {?} lastScrollPosition\n * @param {?} container\n * @param {?} distance\n * @return {?}\n */\nfunction getScrollStats(lastScrollPosition, container, distance) {\n    /** @type {?} */\n    const scrollDown = isScrollingDownwards(lastScrollPosition, container);\n    return {\n        fire: shouldFireScrollEvent(container, distance, scrollDown),\n        scrollDown\n    };\n}\n/**\n * @param {?} position\n * @param {?} scrollState\n * @return {?}\n */\n\n/**\n * @param {?} totalToScroll\n * @param {?} scrollState\n * @return {?}\n */\n\n/**\n * @param {?} scrollState\n * @return {?}\n */\n\n/**\n * @param {?} scroll\n * @param {?} scrollState\n * @param {?} triggered\n * @param {?} isScrollingDown\n * @return {?}\n */\n\n/**\n * @param {?} totalToScroll\n * @param {?} scrollState\n * @param {?} isScrollingDown\n * @return {?}\n */\n\n/**\n * @param {?} scrollState\n * @param {?} scrolledUntilNow\n * @param {?} totalToScroll\n * @return {?}\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass ScrollState {\n    /**\n     * @param {?} __0\n     */\n    constructor({ totalToScroll }) {\n        this.lastScrollPosition = 0;\n        this.lastTotalToScroll = 0;\n        this.totalToScroll = 0;\n        this.triggered = {\n            down: 0,\n            up: 0\n        };\n        this.totalToScroll = totalToScroll;\n    }\n    /**\n     * @param {?} position\n     * @return {?}\n     */\n    updateScrollPosition(position) {\n        return (this.lastScrollPosition = position);\n    }\n    /**\n     * @param {?} totalToScroll\n     * @return {?}\n     */\n    updateTotalToScroll(totalToScroll) {\n        if (this.lastTotalToScroll !== totalToScroll) {\n            this.lastTotalToScroll = this.totalToScroll;\n            this.totalToScroll = totalToScroll;\n        }\n    }\n    /**\n     * @param {?} scrolledUntilNow\n     * @param {?} totalToScroll\n     * @return {?}\n     */\n    updateScroll(scrolledUntilNow, totalToScroll) {\n        this.updateScrollPosition(scrolledUntilNow);\n        this.updateTotalToScroll(totalToScroll);\n    }\n    /**\n     * @param {?} scroll\n     * @param {?} isScrollingDown\n     * @return {?}\n     */\n    updateTriggeredFlag(scroll, isScrollingDown) {\n        if (isScrollingDown) {\n            this.triggered.down = scroll;\n        }\n        else {\n            this.triggered.up = scroll;\n        }\n    }\n    /**\n     * @param {?} totalToScroll\n     * @param {?} isScrollingDown\n     * @return {?}\n     */\n    isTriggeredScroll(totalToScroll, isScrollingDown) {\n        return isScrollingDown\n            ? this.triggered.down === totalToScroll\n            : this.triggered.up === totalToScroll;\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} config\n * @return {?}\n */\nfunction createScroller(config) {\n    const { scrollContainer, scrollWindow, element, fromRoot } = config;\n    /** @type {?} */\n    const resolver = createResolver({\n        axis: new AxisResolver(!config.horizontal),\n        windowElement: resolveContainerElement(scrollContainer, scrollWindow, element, fromRoot)\n    });\n    /** @type {?} */\n    const scrollState = new ScrollState({\n        totalToScroll: calculatePoints(element, resolver)\n    });\n    /** @type {?} */\n    const options = {\n        container: resolver.container,\n        throttle: config.throttle\n    };\n    /** @type {?} */\n    const distance = {\n        up: config.upDistance,\n        down: config.downDistance\n    };\n    return attachScrollEvent(options).pipe(mergeMap(() => of(calculatePoints(element, resolver))), map((positionStats) => toInfiniteScrollParams(scrollState.lastScrollPosition, positionStats, distance)), tap(({ stats }) => scrollState.updateScroll(stats.scrolled, stats.totalToScroll)), filter(({ fire, scrollDown, stats: { totalToScroll } }) => shouldTriggerEvents(config.alwaysCallback, fire, scrollState.isTriggeredScroll(totalToScroll, scrollDown))), tap(({ scrollDown, stats: { totalToScroll } }) => {\n        scrollState.updateTriggeredFlag(totalToScroll, scrollDown);\n    }), map(toInfiniteScrollAction));\n}\n/**\n * @param {?} options\n * @return {?}\n */\nfunction attachScrollEvent(options) {\n    /** @type {?} */\n    let obs = fromEvent(options.container, 'scroll');\n    // For an unknown reason calling `sampleTime()` causes trouble for many users, even with `options.throttle = 0`.\n    // Let's avoid calling the function unless needed.\n    // See https://github.com/orizens/ngx-infinite-scroll/issues/198\n    if (options.throttle) {\n        obs = obs.pipe(sampleTime(options.throttle));\n    }\n    return obs;\n}\n/**\n * @param {?} lastScrollPosition\n * @param {?} stats\n * @param {?} distance\n * @return {?}\n */\nfunction toInfiniteScrollParams(lastScrollPosition, stats, distance) {\n    const { scrollDown, fire } = getScrollStats(lastScrollPosition, stats, distance);\n    return {\n        scrollDown,\n        fire,\n        stats\n    };\n}\n/** @type {?} */\nconst InfiniteScrollActions = {\n    DOWN: '[NGX_ISE] DOWN',\n    UP: '[NGX_ISE] UP'\n};\n/**\n * @param {?} response\n * @return {?}\n */\nfunction toInfiniteScrollAction(response) {\n    const { scrollDown, stats: { scrolled: currentScrollPosition } } = response;\n    return {\n        type: scrollDown ? InfiniteScrollActions.DOWN : InfiniteScrollActions.UP,\n        payload: {\n            currentScrollPosition\n        }\n    };\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass InfiniteScrollDirective {\n    /**\n     * @param {?} element\n     * @param {?} zone\n     */\n    constructor(element, zone) {\n        this.element = element;\n        this.zone = zone;\n        this.scrolled = new EventEmitter();\n        this.scrolledUp = new EventEmitter();\n        this.infiniteScrollDistance = 2;\n        this.infiniteScrollUpDistance = 1.5;\n        this.infiniteScrollThrottle = 150;\n        this.infiniteScrollDisabled = false;\n        this.infiniteScrollContainer = null;\n        this.scrollWindow = true;\n        this.immediateCheck = false;\n        this.horizontal = false;\n        this.alwaysCallback = false;\n        this.fromRoot = false;\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterViewInit() {\n        if (!this.infiniteScrollDisabled) {\n            this.setup();\n        }\n    }\n    /**\n     * @param {?} __0\n     * @return {?}\n     */\n    ngOnChanges({ infiniteScrollContainer, infiniteScrollDisabled, infiniteScrollDistance }) {\n        /** @type {?} */\n        const containerChanged = inputPropChanged(infiniteScrollContainer);\n        /** @type {?} */\n        const disabledChanged = inputPropChanged(infiniteScrollDisabled);\n        /** @type {?} */\n        const distanceChanged = inputPropChanged(infiniteScrollDistance);\n        /** @type {?} */\n        const shouldSetup = (!disabledChanged && !this.infiniteScrollDisabled) ||\n            (disabledChanged && !infiniteScrollDisabled.currentValue) || distanceChanged;\n        if (containerChanged || disabledChanged || distanceChanged) {\n            this.destroyScroller();\n            if (shouldSetup) {\n                this.setup();\n            }\n        }\n    }\n    /**\n     * @return {?}\n     */\n    setup() {\n        if (hasWindowDefined()) {\n            this.zone.runOutsideAngular(() => {\n                this.disposeScroller = createScroller({\n                    fromRoot: this.fromRoot,\n                    alwaysCallback: this.alwaysCallback,\n                    disable: this.infiniteScrollDisabled,\n                    downDistance: this.infiniteScrollDistance,\n                    element: this.element,\n                    horizontal: this.horizontal,\n                    scrollContainer: this.infiniteScrollContainer,\n                    scrollWindow: this.scrollWindow,\n                    throttle: this.infiniteScrollThrottle,\n                    upDistance: this.infiniteScrollUpDistance\n                }).subscribe((payload) => this.zone.run(() => this.handleOnScroll(payload)));\n            });\n        }\n    }\n    /**\n     * @param {?} __0\n     * @return {?}\n     */\n    handleOnScroll({ type, payload }) {\n        switch (type) {\n            case InfiniteScrollActions.DOWN:\n                return this.scrolled.emit(payload);\n            case InfiniteScrollActions.UP:\n                return this.scrolledUp.emit(payload);\n            default:\n                return;\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this.destroyScroller();\n    }\n    /**\n     * @return {?}\n     */\n    destroyScroller() {\n        if (this.disposeScroller) {\n            this.disposeScroller.unsubscribe();\n        }\n    }\n}\nInfiniteScrollDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[infiniteScroll], [infinite-scroll], [data-infinite-scroll]'\n            },] },\n];\n/** @nocollapse */\nInfiniteScrollDirective.ctorParameters = () => [\n    { type: ElementRef },\n    { type: NgZone }\n];\nInfiniteScrollDirective.propDecorators = {\n    scrolled: [{ type: Output }],\n    scrolledUp: [{ type: Output }],\n    infiniteScrollDistance: [{ type: Input }],\n    infiniteScrollUpDistance: [{ type: Input }],\n    infiniteScrollThrottle: [{ type: Input }],\n    infiniteScrollDisabled: [{ type: Input }],\n    infiniteScrollContainer: [{ type: Input }],\n    scrollWindow: [{ type: Input }],\n    immediateCheck: [{ type: Input }],\n    horizontal: [{ type: Input }],\n    alwaysCallback: [{ type: Input }],\n    fromRoot: [{ type: Input }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass InfiniteScrollModule {\n}\nInfiniteScrollModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [InfiniteScrollDirective],\n                exports: [InfiniteScrollDirective],\n                imports: [],\n                providers: []\n            },] },\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Angular library starter.\n * Build an Angular library compatible with AoT compilation & Tree shaking.\n * Written by Roberto Simonetti.\n * MIT license.\n * https://github.com/robisim74/angular-library-starter\n */\n/**\n * Entry point for all public APIs of the package.\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { InfiniteScrollDirective, InfiniteScrollModule };\n//# sourceMappingURL=ngx-infinite-scroll.js.map\n","export default \"<nz-card [nzCover]=\\\"coverTemplate\\\"\\n         [nzActions]=\\\"[actionSetting, actionEdit, actionEllipsis]\\\"\\n         [nzHoverable]=\\\"true\\\"\\n>\\n  <nz-card-meta\\n    nzTitle=\\\"{{img.title}}\\\"\\n  ></nz-card-meta>\\n</nz-card>\\n<ng-template #coverTemplate>\\n  <img src=\\\"{{img.pixelSrc}}\\\"/>\\n  <img lazyLoad=\\\"{{img.src}}\\\">\\n</ng-template>\\n<ng-template #actionSetting>\\n  <i nz-icon nzType=\\\"delete\\\" (click)=\\\"onDeleted(img)\\\"></i>\\n</ng-template>\\n<ng-template #actionEdit>\\n  <i nz-icon nzType=\\\"edit\\\"\\n     nz-popover\\n     [nzPopoverContent]=\\\"editImageTitleTemplate\\\"\\n     [(nzVisible)]=\\\"showPopover\\\"\\n     nzTitle=\\\"Edit image title\\\"\\n     nzPopoverTrigger=\\\"click\\\">\\n  </i>\\n</ng-template>\\n<ng-template #actionEllipsis>\\n  <i nz-icon nzType=\\\"more\\\" (click)=\\\"onShowMore(img)\\\"></i>\\n</ng-template>\\n\\n<ng-template #editImageTitleTemplate>\\n  <form nz-form [formGroup]=\\\"titleForm\\\" (ngSubmit)=\\\"submitForm(img)\\\" class=\\\"image-title-form\\\">\\n    <nz-form-item>\\n      <nz-form-control nzErrorTip=\\\"The title cant be empty\\\">\\n        <input type=\\\"text\\\" nz-input formControlName=\\\"title\\\" placeholder=\\\"Insert title\\\" autofocus/>\\n      </nz-form-control>\\n    </nz-form-item>\\n    <nz-form-item>\\n      <nz-form-control>\\n        <button nz-button nzType=\\\"primary\\\" style=\\\"float: right;\\\" [disabled]=\\\"titleForm.invalid\\\">Change</button>\\n      </nz-form-control>\\n    </nz-form-item>\\n  </form>\\n</ng-template>\\n\"","export default \"<nz-layout class=\\\"gallery-page\\\">\\n  <nz-header class=\\\"gallery-header\\\">\\n    <nz-page-header nzTitle=\\\"My Gallery\\\" [nzSubtitle]=\\\"'Here you can find all your media'\\\"></nz-page-header>\\n  </nz-header>\\n  <nz-spin nzTip=\\\"Loading...\\\" [nzSpinning]=\\\"listLoading\\\" [nzDelay]=\\\"500\\\">\\n    <nz-content class=\\\"gallery-content\\\" infiniteScroll (scrolled)=\\\"loadMore()\\\">\\n      <div nz-row class=\\\"img-list-container\\\">\\n        <div nz-col nzXs=\\\"12\\\" nzSm=\\\"12\\\" nzMd=\\\"8\\\" nzLg=\\\"6\\\" nzXl=\\\"6\\\"\\n             style=\\\" padding: 15px; float: left!important;\\\"\\n             *ngFor=\\\"let img of imgList\\\">\\n          <app-image-card [img]=\\\"img\\\"\\n                          (deleted)=\\\"onDelete($event)\\\"\\n                          (showMore)=\\\"onShowMore($event)\\\"\\n                          (titleChanged)=\\\"onTitleChanged($event)\\\">\\n          </app-image-card>\\n        </div>\\n        <button\\n          *ngIf=\\\"loadMoreSpinner\\\"\\n          class=\\\"loading-button\\\"\\n          nz-button nzType=\\\"link\\\"\\n          nzLoading=\\\"true\\\"\\n          nzSize=\\\"large\\\"\\n          nzBlock=\\\"'true'\\\">\\n          Loading...\\n        </button>\\n      </div>\\n    </nz-content>\\n  </nz-spin>\\n</nz-layout>\\n\\n<nz-drawer\\n  nzWrapClassName=\\\"image-detail-drawer\\\"\\n  nzTitle=\\\"Image Info\\\"\\n  [nzBodyStyle]=\\\"{ height: 'calc(100% - 55px)', overflow: 'auto'}\\\"\\n  [nzVisible]=\\\"visible\\\"\\n  (nzOnClose)=\\\"onClose()\\\"\\n>\\n  <div>\\n    <nz-skeleton [nzActive]=\\\"true\\\" [nzLoading]=\\\"loadingImg\\\" [nzParagraph]=\\\"{ rows: 10 }\\\">\\n      <nz-card [nzCover]=\\\"coverTemplate\\\" [nzBordered]=\\\"false\\\">\\n        <nz-descriptions>\\n          <nz-descriptions-item nzTitle=\\\"Id: \\\"> {{selectedImg?.id}}</nz-descriptions-item>\\n        </nz-descriptions>\\n        <nz-descriptions>\\n          <nz-descriptions-item nzTitle=\\\"Created at: \\\"> {{selectedImg?.created_at | date}}</nz-descriptions-item>\\n        </nz-descriptions>\\n        <nz-descriptions>\\n          <nz-descriptions-item nzTitle=\\\"Updated at: \\\"> {{selectedImg?.updated_at | date}}</nz-descriptions-item>\\n        </nz-descriptions>\\n        <nz-descriptions>\\n          <nz-descriptions-item nzTitle=\\\"Tags: \\\">\\n            <nz-tag style=\\\"margin-bottom: 5px;\\\" [nzColor]=\\\"'blue'\\\"\\n                    *ngFor=\\\"let tag of selectedImg?.tags\\\">{{tag.title}}</nz-tag>\\n          </nz-descriptions-item>\\n        </nz-descriptions>\\n        <ng-template #coverTemplate>\\n          <img alt=\\\"example\\\" src=\\\"{{selectedImg?.urls?.small}}\\\"/>\\n        </ng-template>\\n      </nz-card>\\n    </nz-skeleton>\\n    <nz-divider></nz-divider>\\n    <nz-skeleton [nzActive]=\\\"true\\\" [nzLoading]=\\\"loadingImg\\\" [nzAvatar]=\\\"true\\\">\\n      <nz-card [nzBordered]=\\\"false\\\">\\n        <nz-card-meta\\n          [nzAvatar]=\\\"avatarTemplate\\\"\\n          [nzTitle]=\\\"selectedImg?.user?.name\\\"\\n          [nzDescription]=\\\"selectedImg?.user?.bio\\\"\\n        ></nz-card-meta>\\n        <ng-template #avatarTemplate>\\n          <nz-avatar [nzSrc]=\\\"selectedImg?.user?.profile_image?.medium\\\" nzSize=\\\"large\\\"></nz-avatar>\\n        </ng-template>\\n      </nz-card>\\n    </nz-skeleton>\\n  </div>\\n</nz-drawer>\\n\"","export default \":host {\\n  width: 100%;\\n}\\n:host img {\\n  position: absolute;\\n  left: 0;\\n  top: 0;\\n  max-width: 100%;\\n}\\n:host .ng-lazyloaded {\\n  opacity: 1;\\n}\\n:host ::ng-deep .ant-card {\\n  background: transparent;\\n}\\n:host ::ng-deep .ant-card-actions {\\n  background: transparent;\\n  border-top: none;\\n}\\n:host ::ng-deep .ant-card-body {\\n  background: #f0f2f5;\\n  opacity: 1;\\n  margin-top: -64px;\\n  position: relative;\\n}\\n:host ::ng-deep .ant-card-cover {\\n  width: auto;\\n  height: 250px;\\n  position: relative;\\n  overflow: hidden;\\n}\\n.image-title-form {\\n  width: 260px;\\n}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hdmltYXNsYXRpMS9wcm9qZWN0cy9jbG91ZGluYXJ5L3NyYy9hcHAvY29tcG9uZW50cy9pbWFnZS1jYXJkL2ltYWdlLWNhcmQuY29tcG9uZW50LnNjc3MiLCJzcmMvYXBwL2NvbXBvbmVudHMvaW1hZ2UtY2FyZC9pbWFnZS1jYXJkLmNvbXBvbmVudC5zY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUVBO0VBQ0UsV0FBQTtBQ0RGO0FER0U7RUFDRSxrQkFBQTtFQUNBLE9BQUE7RUFDQSxNQUFBO0VBQ0EsZUFBQTtBQ0RKO0FES0U7RUFDRSxVQUFBO0FDSEo7QURRSTtFQUNFLHVCQUFBO0FDTk47QURTSTtFQUNFLHVCQUFBO0VBQ0EsZ0JBQUE7QUNQTjtBRFVJO0VBQ0UsbUJBQUE7RUFDQSxVQUFBO0VBQ0EsaUJBQUE7RUFDQSxrQkFBQTtBQ1JOO0FEWUk7RUFDRSxXQUFBO0VBQ0EsYUFBQTtFQUNBLGtCQUFBO0VBQ0EsZ0JBQUE7QUNWTjtBRGVBO0VBQ0UsWUFBQTtBQ1pGIiwiZmlsZSI6InNyYy9hcHAvY29tcG9uZW50cy9pbWFnZS1jYXJkL2ltYWdlLWNhcmQuY29tcG9uZW50LnNjc3MiLCJzb3VyY2VzQ29udGVudCI6WyJAaW1wb3J0IFwiLi4vLi4vLi4vdmFyaWFibGVzXCI7XG5cbjpob3N0IHtcbiAgd2lkdGg6IDEwMCU7XG5cbiAgaW1nIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgbGVmdDogMDtcbiAgICB0b3A6IDA7XG4gICAgbWF4LXdpZHRoOiAxMDAlO1xuICB9XG5cblxuICAubmctbGF6eWxvYWRlZCB7XG4gICAgb3BhY2l0eTogMTtcbiAgfVxuXG4gIDo6bmctZGVlcCB7XG5cbiAgICAuYW50LWNhcmQge1xuICAgICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG4gICAgfVxuXG4gICAgLmFudC1jYXJkLWFjdGlvbnMge1xuICAgICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG4gICAgICBib3JkZXItdG9wOiBub25lO1xuICAgIH1cblxuICAgIC5hbnQtY2FyZC1ib2R5IHtcbiAgICAgIGJhY2tncm91bmQ6ICNmMGYyZjU7XG4gICAgICBvcGFjaXR5OiAxO1xuICAgICAgbWFyZ2luLXRvcDogLTY0cHg7XG4gICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgfVxuXG5cbiAgICAuYW50LWNhcmQtY292ZXIge1xuICAgICAgd2lkdGg6IGF1dG87XG4gICAgICBoZWlnaHQ6IDI1MHB4O1xuICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICB9XG4gIH1cbn1cblxuLmltYWdlLXRpdGxlLWZvcm0ge1xuICB3aWR0aDogMjYwcHg7XG59XG4iLCI6aG9zdCB7XG4gIHdpZHRoOiAxMDAlO1xufVxuOmhvc3QgaW1nIHtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICBsZWZ0OiAwO1xuICB0b3A6IDA7XG4gIG1heC13aWR0aDogMTAwJTtcbn1cbjpob3N0IC5uZy1sYXp5bG9hZGVkIHtcbiAgb3BhY2l0eTogMTtcbn1cbjpob3N0IDo6bmctZGVlcCAuYW50LWNhcmQge1xuICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcbn1cbjpob3N0IDo6bmctZGVlcCAuYW50LWNhcmQtYWN0aW9ucyB7XG4gIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xuICBib3JkZXItdG9wOiBub25lO1xufVxuOmhvc3QgOjpuZy1kZWVwIC5hbnQtY2FyZC1ib2R5IHtcbiAgYmFja2dyb3VuZDogI2YwZjJmNTtcbiAgb3BhY2l0eTogMTtcbiAgbWFyZ2luLXRvcDogLTY0cHg7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbn1cbjpob3N0IDo6bmctZGVlcCAuYW50LWNhcmQtY292ZXIge1xuICB3aWR0aDogYXV0bztcbiAgaGVpZ2h0OiAyNTBweDtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xuICBvdmVyZmxvdzogaGlkZGVuO1xufVxuXG4uaW1hZ2UtdGl0bGUtZm9ybSB7XG4gIHdpZHRoOiAyNjBweDtcbn0iXX0= */\"","// ANGULAR\nimport { Component, EventEmitter, Input, OnInit, Output } from '@angular/core';\nimport { FormBuilder, FormGroup, Validators } from '@angular/forms';\n\n// APP\nimport { ImageCard } from './image-card.model';\n\n@Component({\n  selector: 'app-image-card',\n  templateUrl: './image-card.component.html',\n  styleUrls: [ './image-card.component.scss' ]\n})\nexport class ImageCardComponent implements OnInit {\n  /**\n   * a form to hold component inputs\n   */\n  public titleForm: FormGroup;\n\n  /**\n   * a variable to show / hide popover\n   */\n  public showPopover = false;\n\n  /**\n   * img title\n   */\n  @Input() public img: ImageCard;\n\n  /**\n   * fire event when title changed\n   */\n  @Output() public titleChanged = new EventEmitter<{ img: ImageCard, title: string }>();\n\n  /**\n   * fire event when image is deleted\n   */\n  @Output() public deleted = new EventEmitter<ImageCard>();\n\n  /**\n   * fire event when details icon clicked\n   */\n  @Output() public showMore = new EventEmitter<ImageCard>();\n\n\n  constructor(private formBuilder: FormBuilder) {\n  }\n\n  /**\n   * angular init hook\n   */\n  ngOnInit() {\n    this.titleForm = this.formBuilder.group({\n      title: [ this.img.title, Validators.required ],\n    });\n  }\n\n  /**\n   * emit the deleted img when delete icon is clicked\n   * @param img\n   */\n  public onDeleted(img: ImageCard) {\n    this.deleted.emit(img);\n  }\n\n  /**\n   * emit the deleted img when show more icon is clicked\n   * @param img\n   */\n  public onShowMore(img: ImageCard) {\n    this.showMore.emit(img);\n  }\n\n  /**\n   * emit the editable img with the text to replace the title\n   * emit only if the form is valid\n   * @param img\n   */\n  public submitForm(img: ImageCard) {\n    if (this.titleForm.valid) {\n      this.showPopover = false;\n      // fire title changed with the new value\n      this.titleChanged.emit({ img, title: this.titleForm.controls['title'].value });\n    }\n  }\n}\n","export { ImageCard } from './image-card.model';\nexport { ImageCardComponent } from './image-card.component';\n","// ANGULAR\nimport { NgModule } from '@angular/core';\nimport { Routes, RouterModule } from '@angular/router';\nimport { CommonModule } from '@angular/common';\n\n// APP\nimport { GalleryComponent } from './gallery.component';\n\nconst routes: Routes = [\n  {\n    path: '',\n    component: GalleryComponent\n  }\n];\n\n@NgModule({\n  imports: [ RouterModule.forChild(routes) ],\n  exports: [ RouterModule ]\n})\n\n@NgModule({\n  declarations: [],\n  imports: [\n    CommonModule\n  ]\n})\nexport class GalleryRoutingModule {\n}\n","export default \".gallery-page .gallery-header {\\n  background: transparent;\\n}\\n.gallery-page .loading-button:before {\\n  background: transparent;\\n}\\n.gallery-page .gallery-content {\\n  min-height: 100vh;\\n}\\n.gallery-page .img-list-container {\\n  max-width: 1280px;\\n  margin: 0 auto;\\n}\\n.image-detail-drawer {\\n  width: 100% !important;\\n  max-width: 400px;\\n}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hdmltYXNsYXRpMS9wcm9qZWN0cy9jbG91ZGluYXJ5L3NyYy9hcHAvZmVhdHVyZXMvZ2FsbGVyeS9nYWxsZXJ5LmNvbXBvbmVudC5zY3NzIiwic3JjL2FwcC9mZWF0dXJlcy9nYWxsZXJ5L2dhbGxlcnkuY29tcG9uZW50LnNjc3MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0U7RUFDRSx1QkFBQTtBQ0FKO0FESUk7RUFDRSx1QkFBQTtBQ0ZOO0FETUU7RUFDRSxpQkFBQTtBQ0pKO0FET0U7RUFDRSxpQkFBQTtFQUNBLGNBQUE7QUNMSjtBRFNBO0VBQ0Usc0JBQUE7RUFDQSxnQkFBQTtBQ05GIiwiZmlsZSI6InNyYy9hcHAvZmVhdHVyZXMvZ2FsbGVyeS9nYWxsZXJ5LmNvbXBvbmVudC5zY3NzIiwic291cmNlc0NvbnRlbnQiOlsiLmdhbGxlcnktcGFnZSB7XG4gIC5nYWxsZXJ5LWhlYWRlciB7XG4gICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG4gIH1cblxuICAubG9hZGluZy1idXR0b24ge1xuICAgICY6YmVmb3JlIHtcbiAgICAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xuICAgIH1cbiAgfVxuXG4gIC5nYWxsZXJ5LWNvbnRlbnQge1xuICAgIG1pbi1oZWlnaHQ6IDEwMHZoO1xuICB9XG5cbiAgLmltZy1saXN0LWNvbnRhaW5lciB7XG4gICAgbWF4LXdpZHRoOiAxMjgwcHg7XG4gICAgbWFyZ2luOiAwIGF1dG87XG4gIH1cbn1cblxuLmltYWdlLWRldGFpbC1kcmF3ZXIge1xuICB3aWR0aDogMTAwJSAhaW1wb3J0YW50O1xuICBtYXgtd2lkdGg6IDQwMHB4O1xufVxuXG5cbiIsIi5nYWxsZXJ5LXBhZ2UgLmdhbGxlcnktaGVhZGVyIHtcbiAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG59XG4uZ2FsbGVyeS1wYWdlIC5sb2FkaW5nLWJ1dHRvbjpiZWZvcmUge1xuICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcbn1cbi5nYWxsZXJ5LXBhZ2UgLmdhbGxlcnktY29udGVudCB7XG4gIG1pbi1oZWlnaHQ6IDEwMHZoO1xufVxuLmdhbGxlcnktcGFnZSAuaW1nLWxpc3QtY29udGFpbmVyIHtcbiAgbWF4LXdpZHRoOiAxMjgwcHg7XG4gIG1hcmdpbjogMCBhdXRvO1xufVxuXG4uaW1hZ2UtZGV0YWlsLWRyYXdlciB7XG4gIHdpZHRoOiAxMDAlICFpbXBvcnRhbnQ7XG4gIG1heC13aWR0aDogNDAwcHg7XG59Il19 */\"","// ANGULAR\nimport { Component, OnInit, ViewEncapsulation } from '@angular/core';\n\n// APP\nimport { ImageCard } from '../../components/image-card';\nimport { GallerySandboxService } from './services/gallery.sandbox.service';\n\nconst ITEMS_PER_PAGE = 12;\n\n@Component({\n  selector: 'app-gallery',\n  templateUrl: './gallery.component.html',\n  styleUrls: [ './gallery.component.scss' ],\n  encapsulation: ViewEncapsulation.None\n})\nexport class GalleryComponent implements OnInit {\n  /**\n   * array of images to display\n   */\n  public imgList: ImageCard[] = [];\n\n  /**\n   * selected image for show more details\n   */\n  public selectedImg: any = null;\n\n  /**\n   * show / hide img overlay\n   */\n  public visible = false;\n\n  /**\n   * loader when getting selected img details\n   */\n  public loadingImg = false;\n\n  /**\n   * loader when getting the lis of img\n   */\n  public listLoading = true;\n\n  /**\n   * infinite scroll loader\n   */\n  public loadMoreSpinner = false;\n\n  private pageNumber = 1;\n\n  constructor(private sandbox: GallerySandboxService) {\n\n  }\n\n  async ngOnInit() {\n    try {\n      this.imgList = await this.sandbox.getList(this.pageNumber, ITEMS_PER_PAGE);\n    } catch (e) {\n      // error handling\n    }\n    this.listLoading = false;\n  }\n\n  /**\n   * an cb for img remove\n   * remove the selected img from the array\n   * @param image\n   */\n  public onDelete(image: ImageCard) {\n    this.imgList = this.imgList.filter(item => item.id !== image.id);\n  }\n\n  /**\n   * an cb for img show more\n   * extract the id of the img and open the show more overlay\n   * @param image\n   */\n  public async onShowMore(image: ImageCard) {\n    this.visible = true;\n    this.loadingImg = true;\n    try {\n      this.selectedImg = await this.sandbox.getPhoto(image.id);\n    } catch (e) {\n      // error\n    }\n    this.loadingImg = false;\n  }\n\n  /**\n   * an cb for img edit\n   * find the selected img in the array and change the title\n   * @param $event\n   */\n  public onTitleChanged($event) {\n    const { img, title } = $event;\n    let originalImage = this.imgList.find(item => item.id === img.id);\n    if (originalImage) {\n      originalImage.title = title;\n    }\n  }\n\n  /**\n   * a cb for the overlay close event\n   * close overlay and init selected image\n   */\n  public onClose() {\n    this.visible = false;\n    this.selectedImg = null;\n  }\n\n  /**\n   * load more images when scroll is getting to the distance\n   */\n  public async loadMore() {\n    let imgs = [];\n    this.loadMoreSpinner = true;\n    try {\n      imgs = await this.sandbox.getList(++this.pageNumber, ITEMS_PER_PAGE);\n      this.imgList = this.imgList.concat(imgs);\n    } catch (e) {\n      // error\n    }\n    this.loadMoreSpinner = false;\n  }\n}\n","// ANGULAR\nimport { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { ReactiveFormsModule } from '@angular/forms';\n\n// VENDORS\nimport {\n  NgZorroAntdModule,\n  NZ_ICONS\n} from 'ng-zorro-antd';\nimport { DeleteOutline, EditOutline, MoreOutline } from '@ant-design/icons-angular/icons';\nimport { IconDefinition } from '@ant-design/icons-angular';\nimport { LazyLoadImageModule } from 'ng-lazyload-image';\nimport { InfiniteScrollModule } from 'ngx-infinite-scroll';\n\n// APP\nimport { GalleryComponent } from './gallery.component';\nimport { GalleryRoutingModule } from './gallery-routing.module';\nimport { ImageCardComponent } from '../../components/image-card';\n\n\nconst icons: IconDefinition[] = [ DeleteOutline, EditOutline, MoreOutline ];\n\n@NgModule({\n  declarations: [\n    GalleryComponent,\n    ImageCardComponent\n  ],\n  imports: [\n    CommonModule,\n    GalleryRoutingModule,\n    LazyLoadImageModule.forRoot({}),\n    ReactiveFormsModule,\n    NgZorroAntdModule,\n    InfiniteScrollModule\n  ],\n  providers: [\n    {\n      provide: NZ_ICONS, useValue: icons\n    }\n  ]\n})\nexport class GalleryModule {\n}\n","export { GalleryModule } from './gallery.module';\nexport { GalleryComponent } from './gallery.component';\nexport { GallerySandboxService } from './services/gallery.sandbox.service';\nexport { GalleryService } from './services/gallery.service';\n","// ANGULAR\nimport { Injectable } from '@angular/core';\nimport { GalleryService } from './gallery.service';\nimport { ImageCard } from '../../../components/image-card';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class GallerySandboxService {\n\n  constructor(private galleryService: GalleryService) {\n  }\n\n  /**\n   * get a pager options and return img card object\n   * @param page\n   * @param perPage\n   * @param orderBy\n   */\n  public getList(page: number = 1, perPage: number = 10, orderBy: 'latest' | 'oldest' | 'popular' = 'latest'): Promise<ImageCard[]> {\n    return this.galleryService.getList(page, perPage, orderBy)\n      .then(res => res.map((img) => {\n        return {\n          id: img.id,\n          title: img.description || 'Add a title',\n          src: `https://source.unsplash.com/${img.id}/290x250`,\n          pixelSrc: `https://source.unsplash.com/${ img.id }/5x5`,\n          alt: img.alt_description\n        };\n      }));\n  }\n\n  /**\n   * get a specific photo by id\n   * @param id\n   */\n  public getPhoto(id: string){\n    return this.galleryService.getPhoto(id);\n  }\n\n}\n","// ANGULAR\nimport { Injectable } from '@angular/core';\nimport { ImageService } from '../../../share/services/image.service';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class GalleryService {\n\n  constructor(private imgApi: ImageService) {\n  }\n\n  /**\n   * get a pager options and return list of photos from the imgApi\n   * @param page\n   * @param perPage\n   * @param orderBy\n   */\n  public getList(page: number = 1, perPage: number = 10, orderBy: 'latest' | 'oldest' | 'popular' = 'latest'): Promise<any> {\n    return this.imgApi.getList(page, perPage, orderBy);\n  }\n\n  /**\n   * get a specific photo by id\n   * @param id\n   */\n  public getPhoto(id: string): Promise<any> {\n    return this.imgApi.getPhoto(id)\n  }\n}\n"],"sourceRoot":"webpack:///"}